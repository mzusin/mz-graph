/*
https://github.com/mzusin/mz-graph
MIT License      
Copyright (c) 2023-present, Miriam Zusin       
*/
var E=Object.create;var _=Object.defineProperty;var O=Object.getOwnPropertyDescriptor;var V=Object.getOwnPropertyNames;var D=Object.getPrototypeOf,q=Object.prototype.hasOwnProperty;var R=(n,t)=>()=>(t||n((t={exports:{}}).exports,t),t.exports),G=(n,t)=>{for(var a in t)_(n,a,{get:t[a],enumerable:!0})},I=(n,t,a,c)=>{if(t&&typeof t=="object"||typeof t=="function")for(let u of V(t))!q.call(n,u)&&u!==a&&_(n,u,{get:()=>t[u],enumerable:!(c=O(t,u))||c.enumerable});return n};var P=(n,t,a)=>(a=n!=null?E(D(n)):{},I(t||!n||!n.__esModule?_(a,"default",{value:n,enumerable:!0}):a,n)),z=n=>I(_({},"__esModule",{value:!0}),n);var j=R((H,S)=>{S.exports=y;function y(n){this._comparator=n||y.DEFAULT_COMPARATOR,this._elements=[]}y.DEFAULT_COMPARATOR=function(n,t){return typeof n=="number"&&typeof t=="number"?n-t:(n=n.toString(),t=t.toString(),n==t?0:n>t?1:-1)};y.prototype.isEmpty=function(){return this.size()===0};y.prototype.peek=function(){if(this.isEmpty())throw new Error("PriorityQueue is empty");return this._elements[0]};y.prototype.deq=function(){var n=this.peek(),t=this._elements.pop(),a=this.size();if(a===0)return n;this._elements[0]=t;for(var c=0;c<a;){var u=c,v=2*c+1,w=2*c+2;if(v<a&&this._compare(v,u)>=0&&(u=v),w<a&&this._compare(w,u)>=0&&(u=w),u===c)break;this._swap(u,c),c=u}return n};y.prototype.enq=function(n){for(var t=this._elements.push(n),a=t-1;a>0;){var c=Math.floor((a-1)/2);if(this._compare(a,c)<=0)break;this._swap(c,a),a=c}return t};y.prototype.size=function(){return this._elements.length};y.prototype.forEach=function(n){return this._elements.forEach(n)};y.prototype._compare=function(n,t){return this._comparator(this._elements[n],this._elements[t])};y.prototype._swap=function(n,t){var a=this._elements[n];this._elements[n]=this._elements[t],this._elements[t]=a}});var W={};G(W,{graph:()=>$,matrix:()=>U});module.exports=z(W);var M=P(j(),1),$=n=>{let t=new Map,a=e=>{t.has(e)||t.set(e,[])},c=e=>t.has(e),u=e=>{var r;return(r=t.get(e))!=null?r:null},v=(e,r,s)=>{var o,f;(o=t.get(e))==null||o.push({label:r,edgeWeight:s}),n.isDirected||(f=t.get(r))==null||f.push({label:e,edgeWeight:s})},w=()=>{for(let[e,r]of t.entries()){let s=r.map(o=>{let f=o.edgeWeight!==void 0?`(${o.edgeWeight})`:"";return`${o.label}${f}`}).join(", ");console.log(`${e} -> [${s}]`)}},T=(e,r)=>{let s=new Set,o=i=>{let l=[i];for(s.add(i);l.length>0;){let b=l.shift();e(b);let L=u(b)||[];for(let g of L)s.has(g.label)||(s.add(g.label),l.push(g.label))}};if(r!==void 0){o(r);return}let f=t.keys();for(let i of f)s.has(i)||o(i)},A=(e,r)=>{let s=new Set,o=i=>{let l=[i];for(s.add(i);l.length>0;){let b=l.pop();e(b);let L=u(b)||[];for(let g of L)s.has(g.label)||(s.add(g.label),l.push(g.label))}};if(r!==void 0){o(r);return}let f=t.keys();for(let i of f)s.has(i)||o(i)},h=(e,r)=>{let s=new Set,o=i=>{if(s.has(i))return;s.add(i),e(i);let l=u(i);if(l)for(let b of l)o(b.label)};if(r!==void 0){o(r);return}let f=t.keys();for(let i of f)o(i)},d=()=>{let e=new Set,r=o=>{let f=[o];for(e.add(o);f.length>0;){let i=f.pop(),l=u(i)||[];for(let b of l){if(b.label!==i&&e.has(b.label))return!0;e.add(b.label),f.push(b.label)}}return!1},s=t.keys();for(let o of s)if(!e.has(o)&&r(o))return!0;return!1},p=()=>{let e=new Set,r=o=>{let f=[o];for(e.add(o);f.length>0;){let i=f.pop(),l=u(i)||[];for(let b of l){if(e.has(b.label))return!0;e.add(b.label),f.push(b.label)}}return!1},s=t.keys();for(let o of s)if(!e.has(o)&&r(o))return!0;return!1},m=()=>n.isDirected?p():d(),x=e=>{var f,i;let r=new Set,s=new M.default({comparator:(l,b)=>l.distance-b.distance}),o=new Map;for(let l of t.keys())o.set(l,1/0);for(o.set(e,0),s.enq({label:e,distance:0});!s.isEmpty();){let{label:l}=s.deq();if(r.has(l))continue;r.add(l);let b=u(l)||[];for(let L of b){let g=L.edgeWeight,k=((f=o.get(l))!=null?f:0)+g,C=(i=o.get(L.label))!=null?i:1/0;k<C&&(o.set(L.label,k),s.enq({label:L.label,distance:k}))}}return o};return(()=>{if(!n.initial)return;let e=Object.keys(n.initial);for(let r of e){let s=n.initial[r]||[];t.set(r,s)}})(),{addVertex:a,getVertex:u,hasVertex:c,addEdge:v,printGraph:w,bfs:T,dfs:A,dfsRecursive:h,hasCycle:m,findShortestPathDijkstra:x}};var Q=n=>{var t,a;if(n.initial){let c=n.initial.length,u=c>0?n.initial[0].length:0;return[c,u]}return[(t=n.rowsCount)!=null?t:0,(a=n.columnsCount)!=null?a:0]},U=n=>{let[t,a]=Q(n),c=Array(t),u=()=>c,v=(h,d,p)=>{c[h][d]=p,n.isDirected||(c[d][h]=p)},w=()=>{for(let h=0;h<t;h++)console.log(c[h].map(d=>d==null?"-":d).join(" "))},T=h=>{let d=[[0,-1],[0,1],[-1,0],[1,0]],p=[[0,0]],m=[];for(let e=0;e<t;e++)m[e]=[];let x=(e,r)=>e>=0&&e<t&&r>=0&&r<a&&!m[e][r];for(;p.length>0;){let[e,r]=p.shift();if(!m[e][r]){m[e][r]=!0,h(e,r,c[e][r]);for(let s=0;s<d.length;s++){let[o,f]=d[s],i=e+o,l=r+f;x(i,l)&&p.push([i,l])}}}},A=h=>{let d=[[0,-1],[0,1],[-1,0],[1,0]],p=[[0,0]],m=[];for(let e=0;e<t;e++)m[e]=[];let x=(e,r)=>e>=0&&e<t&&r>=0&&r<a&&!m[e][r];for(;p.length>0;){let[e,r]=p.pop();if(!m[e][r]){m[e][r]=!0,h(e,r,c[e][r]);for(let s=0;s<d.length;s++){let[o,f]=d[s],i=e+o,l=r+f;x(i,l)&&p.push([i,l])}}}};return(()=>{if(n.initial){c=n.initial;return}for(let h=0;h<t;h++)c[h]=Array(a),n.defaultValue!==void 0&&c[h].fill(n.defaultValue)})(),{getMatrix:u,addEdge:v,printGraph:w,bfs:T,dfs:A}};0&&(module.exports={graph,matrix});
