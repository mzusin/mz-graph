/*
https://github.com/mzusin/mz-graph
MIT License      
Copyright (c) 2023-present, Miriam Zusin       
*/
var w=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var I=Object.prototype.hasOwnProperty;var j=(l,o)=>{for(var u in o)w(l,u,{get:o[u],enumerable:!0})},A=(l,o,u,c)=>{if(o&&typeof o=="object"||typeof o=="function")for(let d of x(o))!I.call(l,d)&&d!==u&&w(l,d,{get:()=>o[d],enumerable:!(c=y(o,d))||c.enumerable});return l};var M=l=>A(w({},"__esModule",{value:!0}),l);var N={};j(N,{graph:()=>C,matrix:()=>k});module.exports=M(N);var C=l=>{let o=new Map,u=n=>{o.has(n.label)||o.set(n.label,[])},c=n=>{var t;return(t=o.get(n))!=null?t:null},d=(n,t)=>{var r,s;(r=o.get(n.label))==null||r.push(t),l.isDirected||(s=o.get(t.label))==null||s.push(n)},L=()=>{for(let[n,t]of o.entries()){let r=t.map(s=>{let b=s.value!==void 0?`(${s.value})`:"";return`${s.label}${b}`}).join(", ");console.log(`${n} -> [${r}]`)}},p=(n,t)=>{let r=new Set,s=e=>{let i=[e];for(r.add(e);i.length>0;){let a=i.shift();n(a);let h=c(a)||[];for(let f of h)r.has(f.label)||(r.add(f.label),i.push(f.label))}};if(t!==void 0){s(t);return}let b=o.keys();for(let e of b)r.has(e)||s(e)},v=(n,t)=>{let r=new Set,s=e=>{let i=[e];for(r.add(e);i.length>0;){let a=i.pop();n(a);let h=c(a)||[];for(let f of h)r.has(f.label)||(r.add(f.label),i.push(f.label))}};if(t!==void 0){s(t);return}let b=o.keys();for(let e of b)r.has(e)||s(e)},T=(n,t)=>{let r=new Set,s=e=>{if(r.has(e))return;r.add(e),n(e);let i=c(e);if(i)for(let a of i)s(a.label)};if(t!==void 0){s(t);return}let b=o.keys();for(let e of b)s(e)};return(()=>{if(!l.initial)return;let n=Object.keys(l.initial);for(let t of n){let r=l.initial[t]||[];o.set(t,r)}})(),{addVertex:u,getVertex:c,addEdge:d,printGraph:L,bfs:p,dfs:v,dfsRecursive:T}};var S=l=>{var o,u;if(l.initial){let c=l.initial.length,d=c>0?l.initial[0].length:0;return[c,d]}return[(o=l.rowsCount)!=null?o:0,(u=l.columnsCount)!=null?u:0]},k=l=>{let[o,u]=S(l),c=Array(o),d=()=>c,L=(n,t,r)=>{c[n][t]=r,l.isDirected||(c[t][n]=r)},p=()=>{for(let n=0;n<o;n++)console.log(c[n].map(t=>t==null?"-":t).join(" "))},v=n=>{let t=[[0,-1],[0,1],[-1,0],[1,0]],r=[[0,0]],s=[];for(let e=0;e<o;e++)s[e]=[];let b=(e,i)=>e>=0&&e<o&&i>=0&&i<u&&!s[e][i];for(;r.length>0;){let[e,i]=r.shift();if(!s[e][i]){s[e][i]=!0,n(e,i,c[e][i]);for(let a=0;a<t.length;a++){let[h,f]=t[a],m=e+h,g=i+f;b(m,g)&&r.push([m,g])}}}},T=n=>{let t=[[0,-1],[0,1],[-1,0],[1,0]],r=[[0,0]],s=[];for(let e=0;e<o;e++)s[e]=[];let b=(e,i)=>e>=0&&e<o&&i>=0&&i<u&&!s[e][i];for(;r.length>0;){let[e,i]=r.pop();if(!s[e][i]){s[e][i]=!0,n(e,i,c[e][i]);for(let a=0;a<t.length;a++){let[h,f]=t[a],m=e+h,g=i+f;b(m,g)&&r.push([m,g])}}}};return(()=>{if(l.initial){c=l.initial;return}for(let n=0;n<o;n++)c[n]=Array(u),l.defaultValue!==void 0&&c[n].fill(l.defaultValue)})(),{getMatrix:d,addEdge:L,printGraph:p,bfs:v,dfs:T}};0&&(module.exports={graph,matrix});
