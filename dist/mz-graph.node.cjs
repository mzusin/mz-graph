/*
https://github.com/mzusin/mz-graph
MIT License      
Copyright (c) 2023-present, Miriam Zusin       
*/
var y=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var T=Object.getOwnPropertyNames;var p=Object.prototype.hasOwnProperty;var I=(n,e)=>{for(var i in e)y(n,i,{get:e[i],enumerable:!0})},j=(n,e,i,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let d of T(e))!p.call(n,d)&&d!==i&&y(n,d,{get:()=>e[d],enumerable:!(r=x(e,d))||r.enumerable});return n};var v=n=>j(y({},"__esModule",{value:!0}),n);var C={};I(C,{graph:()=>A,matrix:()=>w});module.exports=v(C);var A=n=>{let e=new Map,i=a=>{e.has(a.label)||e.set(a.label,[])},r=a=>{var t;return(t=e.get(a))!=null?t:null},d=(a,t)=>{var s,c;(s=e.get(a.label))==null||s.push(t),n.isDirected||(c=e.get(t.label))==null||c.push(a)},h=()=>{for(let[a,t]of e.entries()){let s=t.map(c=>{let o=c.value!==void 0?`(${c.value})`:"";return`${c.label}${o}`}).join(", ");console.log(`${a} -> [${s}]`)}},g=a=>{let t=new Set,s=o=>{let b=[o];for(t.add(o);b.length>0;){let u=b.shift();a(u);let L=r(u)||[];for(let f of L)t.has(f.label)||(t.add(f.label),b.push(f.label))}},c=e.keys();for(let o of c)t.has(o)||s(o)},m=a=>{let t=new Set,s=o=>{let b=[o];for(t.add(o);b.length>0;){let u=b.pop();a(u);let L=r(u)||[];for(let f of L)t.has(f.label)||(t.add(f.label),b.push(f.label))}},c=e.keys();for(let o of c)t.has(o)||s(o)},l=a=>{let t=new Set,s=o=>{if(t.has(o))return;t.add(o),a(o);let b=r(o);if(b)for(let u of b)s(u.label)},c=e.keys();for(let o of c)s(o)};return(()=>{if(!n.initial)return;let a=Object.keys(n.initial);for(let t of a){let s=n.initial[t]||[];e.set(t,s)}})(),{addVertex:i,getVertex:r,addEdge:d,printGraph:h,bfs:g,dfs:m,dfsRecursive:l}};var M=n=>{var e,i;if(n.initial){let r=n.initial.length,d=r>0?n.initial[0].length:0;return[r,d]}return[(e=n.rowsCount)!=null?e:0,(i=n.columnsCount)!=null?i:0]},w=n=>{let[e,i]=M(n),r=Array(e),d=()=>r,h=(l,a,t)=>{r[l][a]=t,n.isDirected||(r[a][l]=t)},g=()=>{for(let l=0;l<e;l++)console.log(r[l].map(a=>a==null?"-":a).join(" "))},m=()=>{let l=[[0,0]]};return(()=>{if(n.initial){r=n.initial;return}for(let l=0;l<e;l++)r[l]=Array(i),n.defaultValue!==void 0&&r[l].fill(n.defaultValue)})(),{getMatrix:d,addEdge:h,printGraph:g}};0&&(module.exports={graph,matrix});
