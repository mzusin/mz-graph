/*
https://github.com/mzusin/mz-graph
MIT License      
Copyright (c) 2023-present, Miriam Zusin       
*/
var l=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var x=Object.prototype.hasOwnProperty;var T=(t,r)=>{for(var a in r)l(t,a,{get:r[a],enumerable:!0})},y=(t,r,a,s)=>{if(r&&typeof r=="object"||typeof r=="function")for(let f of v(r))!x.call(t,f)&&f!==a&&l(t,f,{get:()=>r[f],enumerable:!(s=m(r,f))||s.enumerable});return t};var I=t=>y(l({},"__esModule",{value:!0}),t);var S={};T(S,{graph:()=>j,matrix:()=>M});module.exports=I(S);var j=t=>{let r=new Map,a=e=>{r.has(e.label)||r.set(e.label,[])},s=e=>{var o;return(o=r.get(e))!=null?o:null};return{addVertex:a,getVertex:s,addEdge:(e,o)=>{var i,d;(i=r.get(e.label))==null||i.push(o),t||(d=r.get(o.label))==null||d.push(e)},printGraph:()=>{for(let[e,o]of r.entries()){let i=o.map(d=>d.label).join(", ");console.log(`${e} -> [${i}]`)}},inorderRecursive:e=>{let o=new Set,i=n=>{if(o.has(n))return;o.add(n);let g=s(n);if(g){for(let b of g)i(b.label);e(n)}},d=r.keys();for(let n of d)i(n)},preorderRecursive:e=>{let o=new Set,i=n=>{if(o.has(n))return;o.add(n),e(n);let g=s(n);if(g)for(let b of g)i(b.label)},d=r.keys();for(let n of d)i(n)},postorderRecursive:e=>{let o=new Set,i=n=>{if(o.has(n))return;o.add(n);let g=s(n);if(g){for(let b of g)i(b.label);e(n)}},d=r.keys();for(let n of d)i(n)}}},M=(t,r,a=void 0)=>{let s=Array(t),f=()=>s,p=(c,u,e)=>{s[c][u]=e,r||(s[u][c]=e)},h=()=>{for(let c=0;c<t;c++)console.log(s[c].map(u=>u==null?"-":u).join(" "))};return(()=>{for(let c=0;c<t;c++)s[c]=Array(t),a!==void 0&&s[c].fill(a)})(),{getMatrix:f,addEdge:p,printGraph:h}};0&&(module.exports={graph,matrix});
