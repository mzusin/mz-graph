/*
https://github.com/mzusin/mz-graph
MIT License      
Copyright (c) 2023-present, Miriam Zusin       
*/
var O=Object.create;var T=Object.defineProperty;var D=Object.getOwnPropertyDescriptor;var V=Object.getOwnPropertyNames;var q=Object.getPrototypeOf,G=Object.prototype.hasOwnProperty;var R=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),z=(n,e)=>{for(var l in e)T(n,l,{get:e[l],enumerable:!0})},C=(n,e,l,u)=>{if(e&&typeof e=="object"||typeof e=="function")for(let h of V(e))!G.call(n,h)&&h!==l&&T(n,h,{get:()=>e[h],enumerable:!(u=D(e,h))||u.enumerable});return n};var P=(n,e,l)=>(l=n!=null?O(q(n)):{},C(e||!n||!n.__esModule?T(l,"default",{value:n,enumerable:!0}):l,n)),$=n=>C(T({},"__esModule",{value:!0}),n);var M=R((H,I)=>{I.exports=w;function w(n){this._comparator=n||w.DEFAULT_COMPARATOR,this._elements=[]}w.DEFAULT_COMPARATOR=function(n,e){return typeof n=="number"&&typeof e=="number"?n-e:(n=n.toString(),e=e.toString(),n==e?0:n>e?1:-1)};w.prototype.isEmpty=function(){return this.size()===0};w.prototype.peek=function(){if(this.isEmpty())throw new Error("PriorityQueue is empty");return this._elements[0]};w.prototype.deq=function(){var n=this.peek(),e=this._elements.pop(),l=this.size();if(l===0)return n;this._elements[0]=e;for(var u=0;u<l;){var h=u,v=2*u+1,x=2*u+2;if(v<l&&this._compare(v,h)>=0&&(h=v),x<l&&this._compare(x,h)>=0&&(h=x),h===u)break;this._swap(h,u),u=h}return n};w.prototype.enq=function(n){for(var e=this._elements.push(n),l=e-1;l>0;){var u=Math.floor((l-1)/2);if(this._compare(l,u)<=0)break;this._swap(u,l),l=u}return e};w.prototype.size=function(){return this._elements.length};w.prototype.forEach=function(n){return this._elements.forEach(n)};w.prototype._compare=function(n,e){return this._comparator(this._elements[n],this._elements[e])};w.prototype._swap=function(n,e){var l=this._elements[n];this._elements[n]=this._elements[e],this._elements[e]=l}});var F={};z(F,{graph:()=>Q,matrix:()=>W});module.exports=$(F);var j=P(M(),1),Q=n=>{let e=new Map,l=t=>{e.has(t)||e.set(t,[])},u=t=>e.has(t),h=t=>{var r;return(r=e.get(t))!=null?r:null},v=(t,r,s)=>{var o,c;(o=e.get(t))==null||o.push({label:r,edgeWeight:s}),n.isDirected||(c=e.get(r))==null||c.push({label:t,edgeWeight:s})},x=()=>{for(let[t,r]of e.entries()){let s=r.map(o=>{let c=o.edgeWeight!==void 0?`(${o.edgeWeight})`:"";return`${o.label}${c}`}).join(", ");console.log(`${t} -> [${s}]`)}},A=(t,r)=>{let s=new Set,o=i=>{let a=[i];for(s.add(i);a.length>0;){let f=a.shift();t(f);let g=h(f)||[];for(let m of g)s.has(m.label)||(s.add(m.label),a.push(m.label))}};if(r!==void 0){o(r);return}let c=e.keys();for(let i of c)s.has(i)||o(i)},S=(t,r)=>{let s=new Set,o=i=>{let a=[i];for(s.add(i);a.length>0;){let f=a.pop();t(f);let g=h(f)||[];for(let m of g)s.has(m.label)||(s.add(m.label),a.push(m.label))}};if(r!==void 0){o(r);return}let c=e.keys();for(let i of c)s.has(i)||o(i)},d=(t,r)=>{let s=new Set,o=i=>{if(s.has(i))return;s.add(i),t(i);let a=h(i);if(a)for(let f of a)o(f.label)};if(r!==void 0){o(r);return}let c=e.keys();for(let i of c)o(i)},p=()=>{let t=new Set,r=o=>{let c=[o];for(t.add(o);c.length>0;){let i=c.pop(),a=h(i)||[];for(let f of a){if(f.label!==i&&t.has(f.label))return!0;t.add(f.label),c.push(f.label)}}return!1},s=e.keys();for(let o of s)if(!t.has(o)&&r(o))return!0;return!1},y=()=>{let t=new Set,r=o=>{let c=[o];for(t.add(o);c.length>0;){let i=c.pop(),a=h(i)||[];for(let f of a){if(t.has(f.label))return!0;t.add(f.label),c.push(f.label)}}return!1},s=e.keys();for(let o of s)if(!t.has(o)&&r(o))return!0;return!1},L=()=>n.isDirected?y():p(),_=t=>{var c,i;let r=new Set,s=new j.default({comparator:(a,f)=>a.distance-f.distance}),o=new Map;for(let a of e.keys())o.set(a,1/0);for(o.set(t,0),s.enq({label:t,distance:0});!s.isEmpty();){let{label:a}=s.deq();if(r.has(a))continue;r.add(a);let f=h(a)||[];for(let g of f){let m=g.edgeWeight,k=((c=o.get(a))!=null?c:0)+m,E=(i=o.get(g.label))!=null?i:1/0;k<E&&(o.set(g.label,k),s.enq({label:g.label,distance:k}))}}return o},b=()=>{var c,i;if(!n.isDirected)throw new Error("Topological sorting is applicable only to directed acyclic graphs.");let t=new Map;for(let[a,f]of e){t.has(a)||t.set(a,0);for(let g of f){let m=(c=t.get(g.label))!=null?c:0;t.set(g.label,m+1)}}let r=[];for(let[a,f]of t)f===0&&r.push(a);let s=[],o=0;for(;r.length>0;){let a=r.shift();if(!a)continue;s.push(a);let f=e.get(a)||[];for(let g of f){let m=((i=t.get(a))!=null?i:0)-1;t.set(a,m),m<=0&&r.push(g.label)}o++}if(o!==e.size)throw new Error("Graph has a cycle.");return s};return(()=>{if(!n.initial)return;let t=Object.keys(n.initial);for(let r of t){let s=n.initial[r]||[];e.set(r,s)}})(),{addVertex:l,getVertex:h,hasVertex:u,addEdge:v,printGraph:x,bfs:A,dfs:S,dfsRecursive:d,hasCycle:L,findShortestPathDijkstra:_,topologicalSortingKahn:b}};var U=n=>{var e,l;if(n.initial){let u=n.initial.length,h=u>0?n.initial[0].length:0;return[u,h]}return[(e=n.rowsCount)!=null?e:0,(l=n.columnsCount)!=null?l:0]},W=n=>{let[e,l]=U(n),u=Array(e),h=()=>u,v=(d,p,y)=>{u[d][p]=y,n.isDirected||(u[p][d]=y)},x=()=>{for(let d=0;d<e;d++)console.log(u[d].map(p=>p==null?"-":p).join(" "))},A=d=>{let p=[[0,-1],[0,1],[-1,0],[1,0]],y=[[0,0]],L=[];for(let b=0;b<e;b++)L[b]=[];let _=(b,t)=>b>=0&&b<e&&t>=0&&t<l&&!L[b][t];for(;y.length>0;){let[b,t]=y.shift();if(!L[b][t]){L[b][t]=!0,d(b,t,u[b][t]);for(let r=0;r<p.length;r++){let[s,o]=p[r],c=b+s,i=t+o;_(c,i)&&y.push([c,i])}}}},S=d=>{let p=[[0,-1],[0,1],[-1,0],[1,0]],y=[[0,0]],L=[];for(let b=0;b<e;b++)L[b]=[];let _=(b,t)=>b>=0&&b<e&&t>=0&&t<l&&!L[b][t];for(;y.length>0;){let[b,t]=y.pop();if(!L[b][t]){L[b][t]=!0,d(b,t,u[b][t]);for(let r=0;r<p.length;r++){let[s,o]=p[r],c=b+s,i=t+o;_(c,i)&&y.push([c,i])}}}};return(()=>{if(n.initial){u=n.initial;return}for(let d=0;d<e;d++)u[d]=Array(l),n.defaultValue!==void 0&&u[d].fill(n.defaultValue)})(),{getMatrix:h,addEdge:v,printGraph:x,bfs:A,dfs:S}};0&&(module.exports={graph,matrix});
