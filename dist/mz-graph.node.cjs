/*
https://github.com/mzusin/mz-graph
MIT License      
Copyright (c) 2023-present, Miriam Zusin       
*/
var l=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var x=Object.prototype.hasOwnProperty;var T=(t,r)=>{for(var s in r)l(t,s,{get:r[s],enumerable:!0})},m=(t,r,s,o)=>{if(r&&typeof r=="object"||typeof r=="function")for(let a of h(r))!x.call(t,a)&&a!==s&&l(t,a,{get:()=>r[a],enumerable:!(o=u(r,a))||o.enumerable});return t};var y=t=>m(l({},"__esModule",{value:!0}),t);var M={};T(M,{graph:()=>I,matrix:()=>j});module.exports=y(M);var I=t=>{let r=new Map,s=n=>{r.has(n.label)||r.set(n.label,[])},o=n=>{var e;return(e=r.get(n))!=null?e:null};return{addVertex:s,getVertex:o,addEdge:(n,e)=>{var i,d;(i=r.get(n.label))==null||i.push(e),t||(d=r.get(e.label))==null||d.push(n)},printGraph:()=>{for(let[n,e]of r.entries()){let i=e.map(d=>d.label).join(", ");console.log(`${n} -> [${i}]`)}},inorderRecursive:n=>{let e=new Set,i=c=>{if(e.has(c))return;e.add(c);let p=o(c);if(p){for(let b of p)i(b.label);n(c)}},d=r.keys();for(let c of d)i(c)}}},j=(t,r,s=void 0)=>{let o=Array(t),a=()=>o,g=(n,e,i)=>{o[n][e]=i,r||(o[e][n]=i)},f=()=>{for(let n=0;n<t;n++)console.log(o[n].map(e=>e==null?"-":e).join(" "))};return(()=>{for(let n=0;n<t;n++)o[n]=Array(t),s!==void 0&&o[n].fill(s)})(),{getMatrix:a,addEdge:g,printGraph:f}};0&&(module.exports={graph,matrix});
