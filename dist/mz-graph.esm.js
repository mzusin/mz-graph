/*
https://github.com/mzusin/mz-graph
MIT License      
Copyright (c) 2023-present, Miriam Zusin       
*/
var C=Object.create;var k=Object.defineProperty;var E=Object.getOwnPropertyDescriptor;var O=Object.getOwnPropertyNames;var V=Object.getPrototypeOf,D=Object.prototype.hasOwnProperty;var q=(n,t)=>()=>(t||n((t={exports:{}}).exports,t),t.exports);var R=(n,t,l,a)=>{if(t&&typeof t=="object"||typeof t=="function")for(let u of O(t))!D.call(n,u)&&u!==l&&k(n,u,{get:()=>t[u],enumerable:!(a=E(t,u))||a.enumerable});return n};var G=(n,t,l)=>(l=n!=null?C(V(n)):{},R(t||!n||!n.__esModule?k(l,"default",{value:n,enumerable:!0}):l,n));var S=q((Q,I)=>{I.exports=y;function y(n){this._comparator=n||y.DEFAULT_COMPARATOR,this._elements=[]}y.DEFAULT_COMPARATOR=function(n,t){return typeof n=="number"&&typeof t=="number"?n-t:(n=n.toString(),t=t.toString(),n==t?0:n>t?1:-1)};y.prototype.isEmpty=function(){return this.size()===0};y.prototype.peek=function(){if(this.isEmpty())throw new Error("PriorityQueue is empty");return this._elements[0]};y.prototype.deq=function(){var n=this.peek(),t=this._elements.pop(),l=this.size();if(l===0)return n;this._elements[0]=t;for(var a=0;a<l;){var u=a,v=2*a+1,w=2*a+2;if(v<l&&this._compare(v,u)>=0&&(u=v),w<l&&this._compare(w,u)>=0&&(u=w),u===a)break;this._swap(u,a),a=u}return n};y.prototype.enq=function(n){for(var t=this._elements.push(n),l=t-1;l>0;){var a=Math.floor((l-1)/2);if(this._compare(l,a)<=0)break;this._swap(a,l),l=a}return t};y.prototype.size=function(){return this._elements.length};y.prototype.forEach=function(n){return this._elements.forEach(n)};y.prototype._compare=function(n,t){return this._comparator(this._elements[n],this._elements[t])};y.prototype._swap=function(n,t){var l=this._elements[n];this._elements[n]=this._elements[t],this._elements[t]=l}});var j=G(S(),1),U=n=>{let t=new Map,l=e=>{t.has(e)||t.set(e,[])},a=e=>t.has(e),u=e=>{var r;return(r=t.get(e))!=null?r:null},v=(e,r,s)=>{var o,f;(o=t.get(e))==null||o.push({label:r,edgeWeight:s}),n.isDirected||(f=t.get(r))==null||f.push({label:e,edgeWeight:s})},w=()=>{for(let[e,r]of t.entries()){let s=r.map(o=>{let f=o.edgeWeight!==void 0?`(${o.edgeWeight})`:"";return`${o.label}${f}`}).join(", ");console.log(`${e} -> [${s}]`)}},_=(e,r)=>{let s=new Set,o=i=>{let c=[i];for(s.add(i);c.length>0;){let b=c.shift();e(b);let L=u(b)||[];for(let g of L)s.has(g.label)||(s.add(g.label),c.push(g.label))}};if(r!==void 0){o(r);return}let f=t.keys();for(let i of f)s.has(i)||o(i)},T=(e,r)=>{let s=new Set,o=i=>{let c=[i];for(s.add(i);c.length>0;){let b=c.pop();e(b);let L=u(b)||[];for(let g of L)s.has(g.label)||(s.add(g.label),c.push(g.label))}};if(r!==void 0){o(r);return}let f=t.keys();for(let i of f)s.has(i)||o(i)},h=(e,r)=>{let s=new Set,o=i=>{if(s.has(i))return;s.add(i),e(i);let c=u(i);if(c)for(let b of c)o(b.label)};if(r!==void 0){o(r);return}let f=t.keys();for(let i of f)o(i)},d=()=>{let e=new Set,r=o=>{let f=[o];for(e.add(o);f.length>0;){let i=f.pop(),c=u(i)||[];for(let b of c){if(b.label!==i&&e.has(b.label))return!0;e.add(b.label),f.push(b.label)}}return!1},s=t.keys();for(let o of s)if(!e.has(o)&&r(o))return!0;return!1},p=()=>{let e=new Set,r=o=>{let f=[o];for(e.add(o);f.length>0;){let i=f.pop(),c=u(i)||[];for(let b of c){if(e.has(b.label))return!0;e.add(b.label),f.push(b.label)}}return!1},s=t.keys();for(let o of s)if(!e.has(o)&&r(o))return!0;return!1},m=()=>n.isDirected?p():d(),x=e=>{var f,i;let r=new Set,s=new j.default({comparator:(c,b)=>c.distance-b.distance}),o=new Map;for(let c of t.keys())o.set(c,1/0);for(o.set(e,0),s.enq({label:e,distance:0});!s.isEmpty();){let{label:c}=s.deq();if(r.has(c))continue;r.add(c);let b=u(c)||[];for(let L of b){let g=L.edgeWeight,A=((f=o.get(c))!=null?f:0)+g,M=(i=o.get(L.label))!=null?i:1/0;A<M&&(o.set(L.label,A),s.enq({label:L.label,distance:A}))}}return o};return(()=>{if(!n.initial)return;let e=Object.keys(n.initial);for(let r of e){let s=n.initial[r]||[];t.set(r,s)}})(),{addVertex:l,getVertex:u,hasVertex:a,addEdge:v,printGraph:w,bfs:_,dfs:T,dfsRecursive:h,hasCycle:m,findShortestPathDijkstra:x}};var P=n=>{var t,l;if(n.initial){let a=n.initial.length,u=a>0?n.initial[0].length:0;return[a,u]}return[(t=n.rowsCount)!=null?t:0,(l=n.columnsCount)!=null?l:0]},F=n=>{let[t,l]=P(n),a=Array(t),u=()=>a,v=(h,d,p)=>{a[h][d]=p,n.isDirected||(a[d][h]=p)},w=()=>{for(let h=0;h<t;h++)console.log(a[h].map(d=>d==null?"-":d).join(" "))},_=h=>{let d=[[0,-1],[0,1],[-1,0],[1,0]],p=[[0,0]],m=[];for(let e=0;e<t;e++)m[e]=[];let x=(e,r)=>e>=0&&e<t&&r>=0&&r<l&&!m[e][r];for(;p.length>0;){let[e,r]=p.shift();if(!m[e][r]){m[e][r]=!0,h(e,r,a[e][r]);for(let s=0;s<d.length;s++){let[o,f]=d[s],i=e+o,c=r+f;x(i,c)&&p.push([i,c])}}}},T=h=>{let d=[[0,-1],[0,1],[-1,0],[1,0]],p=[[0,0]],m=[];for(let e=0;e<t;e++)m[e]=[];let x=(e,r)=>e>=0&&e<t&&r>=0&&r<l&&!m[e][r];for(;p.length>0;){let[e,r]=p.pop();if(!m[e][r]){m[e][r]=!0,h(e,r,a[e][r]);for(let s=0;s<d.length;s++){let[o,f]=d[s],i=e+o,c=r+f;x(i,c)&&p.push([i,c])}}}};return(()=>{if(n.initial){a=n.initial;return}for(let h=0;h<t;h++)a[h]=Array(l),n.defaultValue!==void 0&&a[h].fill(n.defaultValue)})(),{getMatrix:u,addEdge:v,printGraph:w,bfs:_,dfs:T}};export{U as graph,F as matrix};
