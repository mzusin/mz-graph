/*
https://github.com/mzusin/mz-graph
MIT License      
Copyright (c) 2023-present, Miriam Zusin       
*/
var h=f=>{let s=new Map,u=n=>{s.has(n.label)||s.set(n.label,[])},i=n=>{var e;return(e=s.get(n))!=null?e:null};return{addVertex:u,getVertex:i,addEdge:(n,e)=>{var o,c;(o=s.get(n.label))==null||o.push(e),f||(c=s.get(e.label))==null||c.push(n)},printGraph:()=>{for(let[n,e]of s.entries()){let o=e.map(c=>c.label).join(", ");console.log(`${n} -> [${o}]`)}},inorderRecursive:n=>{let e=new Set,o=r=>{if(e.has(r))return;e.add(r);let d=i(r);if(d){for(let g of d)o(g.label);n(r)}},c=s.keys();for(let r of c)o(r)},preorderRecursive:n=>{let e=new Set,o=r=>{if(e.has(r))return;e.add(r),n(r);let d=i(r);if(d)for(let g of d)o(g.label)},c=s.keys();for(let r of c)o(r)},postorderRecursive:n=>{let e=new Set,o=r=>{if(e.has(r))return;e.add(r);let d=i(r);if(d){for(let g of d)o(g.label);n(r)}},c=s.keys();for(let r of c)o(r)}}},m=(f,s,u=void 0)=>{let i=Array(f),b=()=>i,l=(t,a,n)=>{i[t][a]=n,s||(i[a][t]=n)},p=()=>{for(let t=0;t<f;t++)console.log(i[t].map(a=>a==null?"-":a).join(" "))};return(()=>{for(let t=0;t<f;t++)i[t]=Array(f),u!==void 0&&i[t].fill(u)})(),{getMatrix:b,addEdge:l,printGraph:p}};export{h as graph,m as matrix};
