/*
https://github.com/mzusin/mz-graph
MIT License      
Copyright (c) 2023-present, Miriam Zusin       
*/
var E=Object.create;var k=Object.defineProperty;var O=Object.getOwnPropertyDescriptor;var D=Object.getOwnPropertyNames;var V=Object.getPrototypeOf,q=Object.prototype.hasOwnProperty;var G=(n,t)=>()=>(t||n((t={exports:{}}).exports,t),t.exports);var R=(n,t,b,c)=>{if(t&&typeof t=="object"||typeof t=="function")for(let h of D(t))!q.call(n,h)&&h!==b&&k(n,h,{get:()=>t[h],enumerable:!(c=O(t,h))||c.enumerable});return n};var z=(n,t,b)=>(b=n!=null?E(V(n)):{},R(t||!n||!n.__esModule?k(b,"default",{value:n,enumerable:!0}):b,n));var I=G((U,C)=>{C.exports=w;function w(n){this._comparator=n||w.DEFAULT_COMPARATOR,this._elements=[]}w.DEFAULT_COMPARATOR=function(n,t){return typeof n=="number"&&typeof t=="number"?n-t:(n=n.toString(),t=t.toString(),n==t?0:n>t?1:-1)};w.prototype.isEmpty=function(){return this.size()===0};w.prototype.peek=function(){if(this.isEmpty())throw new Error("PriorityQueue is empty");return this._elements[0]};w.prototype.deq=function(){var n=this.peek(),t=this._elements.pop(),b=this.size();if(b===0)return n;this._elements[0]=t;for(var c=0;c<b;){var h=c,v=2*c+1,x=2*c+2;if(v<b&&this._compare(v,h)>=0&&(h=v),x<b&&this._compare(x,h)>=0&&(h=x),h===c)break;this._swap(h,c),c=h}return n};w.prototype.enq=function(n){for(var t=this._elements.push(n),b=t-1;b>0;){var c=Math.floor((b-1)/2);if(this._compare(b,c)<=0)break;this._swap(c,b),b=c}return t};w.prototype.size=function(){return this._elements.length};w.prototype.forEach=function(n){return this._elements.forEach(n)};w.prototype._compare=function(n,t){return this._comparator(this._elements[n],this._elements[t])};w.prototype._swap=function(n,t){var b=this._elements[n];this._elements[n]=this._elements[t],this._elements[t]=b}});var M=z(I(),1),W=n=>{let t=new Map,b=e=>{t.has(e)||t.set(e,[])},c=e=>t.has(e),h=e=>{var r;return(r=t.get(e))!=null?r:null},v=(e,r,s)=>{var o,l;(o=t.get(e))==null||o.push({label:r,edgeWeight:s}),n.isDirected||(l=t.get(r))==null||l.push({label:e,edgeWeight:s})},x=()=>{for(let[e,r]of t.entries()){let s=r.map(o=>{let l=o.edgeWeight!==void 0?`(${o.edgeWeight})`:"";return`${o.label}${l}`}).join(", ");console.log(`${e} -> [${s}]`)}},T=(e,r)=>{let s=new Set,o=i=>{let a=[i];for(s.add(i);a.length>0;){let f=a.shift();e(f);let g=h(f)||[];for(let m of g)s.has(m.label)||(s.add(m.label),a.push(m.label))}};if(r!==void 0){o(r);return}let l=t.keys();for(let i of l)s.has(i)||o(i)},A=(e,r)=>{let s=new Set,o=i=>{let a=[i];for(s.add(i);a.length>0;){let f=a.pop();e(f);let g=h(f)||[];for(let m of g)s.has(m.label)||(s.add(m.label),a.push(m.label))}};if(r!==void 0){o(r);return}let l=t.keys();for(let i of l)s.has(i)||o(i)},d=(e,r)=>{let s=new Set,o=i=>{if(s.has(i))return;s.add(i),e(i);let a=h(i);if(a)for(let f of a)o(f.label)};if(r!==void 0){o(r);return}let l=t.keys();for(let i of l)o(i)},p=()=>{let e=new Set,r=o=>{let l=[o];for(e.add(o);l.length>0;){let i=l.pop(),a=h(i)||[];for(let f of a){if(f.label!==i&&e.has(f.label))return!0;e.add(f.label),l.push(f.label)}}return!1},s=t.keys();for(let o of s)if(!e.has(o)&&r(o))return!0;return!1},y=()=>{let e=new Set,r=o=>{let l=[o];for(e.add(o);l.length>0;){let i=l.pop(),a=h(i)||[];for(let f of a){if(e.has(f.label))return!0;e.add(f.label),l.push(f.label)}}return!1},s=t.keys();for(let o of s)if(!e.has(o)&&r(o))return!0;return!1},L=()=>n.isDirected?y():p(),_=e=>{var l,i;let r=new Set,s=new M.default({comparator:(a,f)=>a.distance-f.distance}),o=new Map;for(let a of t.keys())o.set(a,1/0);for(o.set(e,0),s.enq({label:e,distance:0});!s.isEmpty();){let{label:a}=s.deq();if(r.has(a))continue;r.add(a);let f=h(a)||[];for(let g of f){let m=g.edgeWeight,S=((l=o.get(a))!=null?l:0)+m,j=(i=o.get(g.label))!=null?i:1/0;S<j&&(o.set(g.label,S),s.enq({label:g.label,distance:S}))}}return o},u=()=>{var l,i;if(!n.isDirected)throw new Error("Topological sorting is applicable only to directed acyclic graphs.");let e=new Map;for(let[a,f]of t){e.has(a)||e.set(a,0);for(let g of f){let m=(l=e.get(g.label))!=null?l:0;e.set(g.label,m+1)}}let r=[];for(let[a,f]of e)f===0&&r.push(a);let s=[],o=0;for(;r.length>0;){let a=r.shift();if(!a)continue;s.push(a);let f=t.get(a)||[];for(let g of f){let m=((i=e.get(a))!=null?i:0)-1;e.set(a,m),m<=0&&r.push(g.label)}o++}if(o!==t.size)throw new Error("Graph has a cycle.");return s};return(()=>{if(!n.initial)return;let e=Object.keys(n.initial);for(let r of e){let s=n.initial[r]||[];t.set(r,s)}})(),{addVertex:b,getVertex:h,hasVertex:c,addEdge:v,printGraph:x,bfs:T,dfs:A,dfsRecursive:d,hasCycle:L,findShortestPathDijkstra:_,topologicalSortingKahn:u}};var P=n=>{var t,b;if(n.initial){let c=n.initial.length,h=c>0?n.initial[0].length:0;return[c,h]}return[(t=n.rowsCount)!=null?t:0,(b=n.columnsCount)!=null?b:0]},K=n=>{let[t,b]=P(n),c=Array(t),h=()=>c,v=(d,p,y)=>{c[d][p]=y,n.isDirected||(c[p][d]=y)},x=()=>{for(let d=0;d<t;d++)console.log(c[d].map(p=>p==null?"-":p).join(" "))},T=d=>{let p=[[0,-1],[0,1],[-1,0],[1,0]],y=[[0,0]],L=[];for(let u=0;u<t;u++)L[u]=[];let _=(u,e)=>u>=0&&u<t&&e>=0&&e<b&&!L[u][e];for(;y.length>0;){let[u,e]=y.shift();if(!L[u][e]){L[u][e]=!0,d(u,e,c[u][e]);for(let r=0;r<p.length;r++){let[s,o]=p[r],l=u+s,i=e+o;_(l,i)&&y.push([l,i])}}}},A=d=>{let p=[[0,-1],[0,1],[-1,0],[1,0]],y=[[0,0]],L=[];for(let u=0;u<t;u++)L[u]=[];let _=(u,e)=>u>=0&&u<t&&e>=0&&e<b&&!L[u][e];for(;y.length>0;){let[u,e]=y.pop();if(!L[u][e]){L[u][e]=!0,d(u,e,c[u][e]);for(let r=0;r<p.length;r++){let[s,o]=p[r],l=u+s,i=e+o;_(l,i)&&y.push([l,i])}}}};return(()=>{if(n.initial){c=n.initial;return}for(let d=0;d<t;d++)c[d]=Array(b),n.defaultValue!==void 0&&c[d].fill(n.defaultValue)})(),{getMatrix:h,addEdge:v,printGraph:x,bfs:T,dfs:A}};export{W as graph,K as matrix};
