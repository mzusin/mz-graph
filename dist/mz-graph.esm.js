/*
https://github.com/mzusin/mz-graph
MIT License      
Copyright (c) 2023-present, Miriam Zusin       
*/
var I=i=>{let s=new Map,g=t=>{s.has(t.label)||s.set(t.label,[])},c=t=>{var o;return(o=s.get(t))!=null?o:null},L=(t,o)=>{var e,n;(e=s.get(t.label))==null||e.push(o),i.isDirected||(n=s.get(o.label))==null||n.push(t)},p=()=>{for(let[t,o]of s.entries()){let e=o.map(n=>{let l=n.value!==void 0?`(${n.value})`:"";return`${n.label}${l}`}).join(", ");console.log(`${t} -> [${e}]`)}},v=(t,o)=>{let e=new Set,n=r=>{let u=[r];for(e.add(r);u.length>0;){let a=u.shift();t(a);let h=c(a)||[];for(let m of h)e.has(m.label)||(e.add(m.label),u.push(m.label))}};if(o!==void 0){n(o);return}let l=s.keys();for(let r of l)e.has(r)||n(r)},y=(t,o)=>{let e=new Set,n=r=>{let u=[r];for(e.add(r);u.length>0;){let a=u.pop();t(a);let h=c(a)||[];for(let m of h)e.has(m.label)||(e.add(m.label),u.push(m.label))}};if(o!==void 0){n(o);return}let l=s.keys();for(let r of l)e.has(r)||n(r)},w=(t,o)=>{let e=new Set,n=r=>{if(e.has(r))return;e.add(r),t(r);let u=c(r);if(u)for(let a of u)n(a.label)};if(o!==void 0){n(o);return}let l=s.keys();for(let r of l)n(r)},b=()=>{let t=new Set,o=n=>{let l=[n];for(t.add(n);l.length>0;){let r=l.pop(),u=c(r)||[];for(let a of u){if(a.label!==r&&t.has(a.label))return!0;t.add(a.label),l.push(a.label)}}return!1},e=s.keys();for(let n of e)if(!t.has(n)&&o(n))return!0;return!1},d=()=>{let t=new Set,o=n=>{let l=[n];for(t.add(n);l.length>0;){let r=l.pop(),u=c(r)||[];for(let a of u){if(t.has(a.label))return!0;t.add(a.label),l.push(a.label)}}return!1},e=s.keys();for(let n of e)if(!t.has(n)&&o(n))return!0;return!1},f=()=>i.isDirected?d():b();return(()=>{if(!i.initial)return;let t=Object.keys(i.initial);for(let o of t){let e=i.initial[o]||[];s.set(o,e)}})(),{addVertex:g,getVertex:c,addEdge:L,printGraph:p,bfs:v,dfs:y,dfsRecursive:w,hasCycle:f}};var T=i=>{var s,g;if(i.initial){let c=i.initial.length,L=c>0?i.initial[0].length:0;return[c,L]}return[(s=i.rowsCount)!=null?s:0,(g=i.columnsCount)!=null?g:0]},j=i=>{let[s,g]=T(i),c=Array(s),L=()=>c,p=(b,d,f)=>{c[b][d]=f,i.isDirected||(c[d][b]=f)},v=()=>{for(let b=0;b<s;b++)console.log(c[b].map(d=>d==null?"-":d).join(" "))},y=b=>{let d=[[0,-1],[0,1],[-1,0],[1,0]],f=[[0,0]],t=[];for(let e=0;e<s;e++)t[e]=[];let o=(e,n)=>e>=0&&e<s&&n>=0&&n<g&&!t[e][n];for(;f.length>0;){let[e,n]=f.shift();if(!t[e][n]){t[e][n]=!0,b(e,n,c[e][n]);for(let l=0;l<d.length;l++){let[r,u]=d[l],a=e+r,h=n+u;o(a,h)&&f.push([a,h])}}}},w=b=>{let d=[[0,-1],[0,1],[-1,0],[1,0]],f=[[0,0]],t=[];for(let e=0;e<s;e++)t[e]=[];let o=(e,n)=>e>=0&&e<s&&n>=0&&n<g&&!t[e][n];for(;f.length>0;){let[e,n]=f.pop();if(!t[e][n]){t[e][n]=!0,b(e,n,c[e][n]);for(let l=0;l<d.length;l++){let[r,u]=d[l],a=e+r,h=n+u;o(a,h)&&f.push([a,h])}}}};return(()=>{if(i.initial){c=i.initial;return}for(let b=0;b<s;b++)c[b]=Array(g),i.defaultValue!==void 0&&c[b].fill(i.defaultValue)})(),{getMatrix:L,addEdge:p,printGraph:v,bfs:y,dfs:w}};export{I as graph,j as matrix};
