/*
https://github.com/mzusin/mz-graph
MIT License      
Copyright (c) 2023-present, Miriam Zusin       
*/
var j=Object.create;var I=Object.defineProperty;var M=Object.getOwnPropertyDescriptor;var C=Object.getOwnPropertyNames;var E=Object.getPrototypeOf,O=Object.prototype.hasOwnProperty;var D=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports);var q=(n,e,l,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let b of C(e))!O.call(n,b)&&b!==l&&I(n,b,{get:()=>e[b],enumerable:!(i=M(e,b))||i.enumerable});return n};var R=(n,e,l)=>(l=n!=null?j(E(n)):{},q(e||!n||!n.__esModule?I(l,"default",{value:n,enumerable:!0}):l,n));var k=D((P,A)=>{A.exports=y;function y(n){this._comparator=n||y.DEFAULT_COMPARATOR,this._elements=[]}y.DEFAULT_COMPARATOR=function(n,e){return typeof n=="number"&&typeof e=="number"?n-e:(n=n.toString(),e=e.toString(),n==e?0:n>e?1:-1)};y.prototype.isEmpty=function(){return this.size()===0};y.prototype.peek=function(){if(this.isEmpty())throw new Error("PriorityQueue is empty");return this._elements[0]};y.prototype.deq=function(){var n=this.peek(),e=this._elements.pop(),l=this.size();if(l===0)return n;this._elements[0]=e;for(var i=0;i<l;){var b=i,w=2*i+1,g=2*i+2;if(w<l&&this._compare(w,b)>=0&&(b=w),g<l&&this._compare(g,b)>=0&&(b=g),b===i)break;this._swap(b,i),i=b}return n};y.prototype.enq=function(n){for(var e=this._elements.push(n),l=e-1;l>0;){var i=Math.floor((l-1)/2);if(this._compare(l,i)<=0)break;this._swap(i,l),l=i}return e};y.prototype.size=function(){return this._elements.length};y.prototype.forEach=function(n){return this._elements.forEach(n)};y.prototype._compare=function(n,e){return this._comparator(this._elements[n],this._elements[e])};y.prototype._swap=function(n,e){var l=this._elements[n];this._elements[n]=this._elements[e],this._elements[e]=l}});var S=R(k(),1),V=n=>{let e=new Map,l=a=>{e.has(a.label)||e.set(a.label,[])},i=a=>{var t;return(t=e.get(a))!=null?t:null},b=(a,t)=>{var r,o;(r=e.get(a.label))==null||r.push(t),n.isDirected||(o=e.get(t.label))==null||o.push(a)},w=()=>{for(let[a,t]of e.entries()){let r=t.map(o=>{let f=o.value!==void 0?`(${o.value})`:"";return`${o.label}${f}`}).join(", ");console.log(`${a} -> [${r}]`)}},g=(a,t)=>{let r=new Set,o=s=>{let u=[s];for(r.add(s);u.length>0;){let c=u.shift();a(c);let L=i(c)||[];for(let v of L)r.has(v.label)||(r.add(v.label),u.push(v.label))}};if(t!==void 0){o(t);return}let f=e.keys();for(let s of f)r.has(s)||o(s)},_=(a,t)=>{let r=new Set,o=s=>{let u=[s];for(r.add(s);u.length>0;){let c=u.pop();a(c);let L=i(c)||[];for(let v of L)r.has(v.label)||(r.add(v.label),u.push(v.label))}};if(t!==void 0){o(t);return}let f=e.keys();for(let s of f)r.has(s)||o(s)},T=(a,t)=>{let r=new Set,o=s=>{if(r.has(s))return;r.add(s),a(s);let u=i(s);if(u)for(let c of u)o(c.label)};if(t!==void 0){o(t);return}let f=e.keys();for(let s of f)o(s)},d=()=>{let a=new Set,t=o=>{let f=[o];for(a.add(o);f.length>0;){let s=f.pop(),u=i(s)||[];for(let c of u){if(c.label!==s&&a.has(c.label))return!0;a.add(c.label),f.push(c.label)}}return!1},r=e.keys();for(let o of r)if(!a.has(o)&&t(o))return!0;return!1},h=()=>{let a=new Set,t=o=>{let f=[o];for(a.add(o);f.length>0;){let s=f.pop(),u=i(s)||[];for(let c of u){if(a.has(c.label))return!0;a.add(c.label),f.push(c.label)}}return!1},r=e.keys();for(let o of r)if(!a.has(o)&&t(o))return!0;return!1},p=()=>n.isDirected?h():d(),m=a=>{var f;let t=new Set,r=new S.default({comparator:(s,u)=>s.distance-u.distance}),o=new Map;for(let s of e.keys())o.set(s,1/0);for(o.set(a,0),r.enq({label:a,distance:0});!r.isEmpty();){let{label:s,distance:u}=r.deq();if(t.has(s))continue;t.add(s);let c=i(s)||[];for(let L of c){let v=(f=L.value)!=null?f:0,x=o[s]+v;x<o[L.label]&&(o[L.label]=x,r.enq({label:L.label,distance:x}))}}return o};return(()=>{if(!n.initial)return;let a=Object.keys(n.initial);for(let t of a){let r=n.initial[t]||[];e.set(t,r)}})(),{addVertex:l,getVertex:i,addEdge:b,printGraph:w,bfs:g,dfs:_,dfsRecursive:T,hasCycle:p,findShortestPathDijkstra:m}};var G=n=>{var e,l;if(n.initial){let i=n.initial.length,b=i>0?n.initial[0].length:0;return[i,b]}return[(e=n.rowsCount)!=null?e:0,(l=n.columnsCount)!=null?l:0]},$=n=>{let[e,l]=G(n),i=Array(e),b=()=>i,w=(d,h,p)=>{i[d][h]=p,n.isDirected||(i[h][d]=p)},g=()=>{for(let d=0;d<e;d++)console.log(i[d].map(h=>h==null?"-":h).join(" "))},_=d=>{let h=[[0,-1],[0,1],[-1,0],[1,0]],p=[[0,0]],m=[];for(let t=0;t<e;t++)m[t]=[];let a=(t,r)=>t>=0&&t<e&&r>=0&&r<l&&!m[t][r];for(;p.length>0;){let[t,r]=p.shift();if(!m[t][r]){m[t][r]=!0,d(t,r,i[t][r]);for(let o=0;o<h.length;o++){let[f,s]=h[o],u=t+f,c=r+s;a(u,c)&&p.push([u,c])}}}},T=d=>{let h=[[0,-1],[0,1],[-1,0],[1,0]],p=[[0,0]],m=[];for(let t=0;t<e;t++)m[t]=[];let a=(t,r)=>t>=0&&t<e&&r>=0&&r<l&&!m[t][r];for(;p.length>0;){let[t,r]=p.pop();if(!m[t][r]){m[t][r]=!0,d(t,r,i[t][r]);for(let o=0;o<h.length;o++){let[f,s]=h[o],u=t+f,c=r+s;a(u,c)&&p.push([u,c])}}}};return(()=>{if(n.initial){i=n.initial;return}for(let d=0;d<e;d++)i[d]=Array(l),n.defaultValue!==void 0&&i[d].fill(n.defaultValue)})(),{getMatrix:b,addEdge:w,printGraph:g,bfs:_,dfs:T}};export{V as graph,$ as matrix};
